# Программа для проверки введённого пароля
## 1. О программе 
Программа написана на ассемблере. При запуске просит пользователя ввести пароль. Считывает введённый пароль с консоли, помещает строку в отведённый буфер, затем сравнивает с правильным паролем (_Password_). Сравнение производится двумя способами:
* С помощью функции _StrCmp_, похожей на аналогичную функцию C, сравнивающей строки посимвольно. Функция возвращает 1, если строки совпали, 0 – в противном случае (Важно! В данный момент эта проверка не используется для добавления уязвимости в программу).
* С помощью подсчёта хэш-суммы введённой строки. Хэш сумма считается следующим образом: сначала подсчитывается сумма ASCII-кодов символов введённой строки. Затем подсчитывается сумма остатков  от деления этих ASCII-кодов, умножается на 8 и добавляется к предыдущей сумме.
По результатам сравнения программа выводит надпись _Allowed_ (от английского _access is allowed_ –  “доступ разрешён”), если введённый пароль совпадает с верным, и _Denied_ (от английского _access is denied_ – “доступ запрещён”), если введённый пароль неверный.  

## 2. Уязвимости
В учебных целях в программе предусмотрены две уязвимости, позволяющие добиться “разрешения доступа”, то есть выведения на экран надписи _Allowed_ даже при неверном пароле.
### 1. Первая уязвимость
Первая уязвимость заключается в отключении _StrCmp_ и сравнении строк исключительно подсчётом хэш-суммы. В таком случае “доступ” может быть получен при введении неверного пароля с той же хэш-суммой (например, этого же пароля в обратном порядке: _abobA_ вместо _Aboba_).
### 2. Вторая уязвимость
Вторая уязвимость связана с переполнением буфера. Так, при считывании строки с консоли максимальная допустимая длина строки – 100 символов, в то время как в действительности для буфера выделено 10 байт, из которых первые два отвечают за максимальную возможную длину строки и фактическую длину введённой строки, то есть на самом деле без потери следующих за буфером данных ввести можно только 8 символов! Таким образом, если ввести 10 произвольных символов, затем слово _Please_ и пробел за ним (например, _0123456789Please_ ), в консоли выведется надпись “Allowed”. Это произойдёт по следующим причинам: первые 10 символов заполнят буфер, выделенный для введённого пароля. Слово _Please_ имеет такую же длину, как слово _Denied_, поэтому вместе с пробелом оно полностью “затирает” место в памяти, занятое строкой _Denied$_ ($ - символ конца строки, важно “затереть” и его тоже, чтобы последующая надпись _Allowed_ всё-таки напечаталась). Таким образом, введённый пароль будет считаться неверным, программа соберётся распечатать слово _Denied_, но вместо него распечатается слово _Please_, расположенное в памяти по этому адресу (оно “наложится” на уже напечатанное в консоли _Please_ в начале запроса, так что подмену строк никто не заподозрит ;) ). Из-за отсутствия символа конца строки выведется и идущее следующим в памяти _Allowed_. 

## 3. Попытки взлома
Через дизассемблер я заметила, что Марина считывает строку через функцию 0Ah (ввод строки) и сохраняет в буффер, который лежит перед строками "\n Denied" и "'\n Allowed". Все также просматривая дизассемблерный код, легко заметить в каких случаях она выводит эти строки. Если введенный пароль совпал, то "Denied", если нет, то "Allowed". Таким образом можно переполнить буффер ввода (он состоит из 10 символов), потом затереть \n, будет печататься что-то вместо "Denied", затереть "$", который указывает на конец выводимой строки. Затерев "$", при выводе неправильного пароля, будет продолжать выводится строка до следующего "$". Следующий "$" встречается после строки "Allowed".

Затерев \n после 10 символов буффера ввода, строка, которая будет выводится, будет показываться на строке, где была надпись "Please enter the password". Поэтому, чтобы все выглядело корректно можно написать вводимый пароль из 10 символов, например, "0123456789", после написать "Please", который затерет "\n" и строку о неправильном пароле и поставить 0, чтобы затереть конец выводимой строки. Таким образом всегд будет выводится строка о введении правильного пароля.

Полная строка, которую я вводила для взлома:
```
'0123456789Please '
```

Далее также смотря дизассемблерный код, я заметила как она сравнивает строки. Она считает сумму символов строки и сравнивает ее с правильной суммой. После вызова функции, она сравнивает значение с 0245 (в 16 формате) и делает прыжки в зависимости от случая. 0245 как раз и является корректной суммой пароля. Понять функцию подсчета было сложнее.

Сначала она считает сумму всех символов (их ASCLL кодов), потом считает вновь сумму, но делит каждый код символа на 7 и берет остаток. После сумму остатков сдвигом на 3 вправо умножает на 8. И весь этот результат прибавляет к обычной сумме кодов символов. Таким образом и получается правильная сумма символов строки.

Дальше было самое сложное, придумать строку, которая будет давать такую же сумму. Я придумала взять n (0 <= n <= 10) одинаковых символов и пытаться подбирать сумму. Можно сделать уравнение

```
x * n + (x % 7) * n * 8 = 581, где x - код символа, n - кол-во символов
Пусть n = 7:
x * 7 + (x % 7) * 56 = 581
примерно прикидывая значение x получается код символа 59 (остаток 3 при делении на 7)
59 * 7 + 3 * 56 = 581
```

Символ с кодом 59 ----> ';'. Таким образом, вводя строку ';;;;;;;' получается верная сумма строки и вывыдится "Allowed".

На си я написала программу, которая может изменить ее код так, чтобы при вводе неправильного пароля выводилось "Allowed". После сверки праивльной суммы символов с суммой из введенной строки она делает jump на метку, где выводится строка с адресом 01AB, которая выводит "Denied". Я затерла этот прыжок, использя nop. Таким образом прыжок на вывод "Denied" никогда не будет происходить, а всегда будет выводиться "Allowed".
